{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pylliterate: python illiterate programing","text":"<p>Disclaimer: This code is a copy with improvements of the original illiterate project because was discontinued since 2022.</p> <p> </p> <p>Unobtrusive literate programming experience for Python pragmatists</p> <p><code>pylliterate</code> is a Python module that helps you apply some of the literate programming paradigm without requiring a meta-programming language (like <code>noweb</code>) or any preprocessing step to actually get your code up and running.</p> <p>It works kind of opposite to how literate programming suggests, in the sense that you write code-first and embed documentation into your code. I know, purist literate programmers will hate this but hey, it's a compromise.</p>"},{"location":"#what-is-all-this-python-il-literatepyliterate-programming-about","title":"What is all this (python il-literate)pyliterate programming about?","text":"<p>If you've never heard about literate programming before, then I suggest you to read at least the  Wikipedia entry and then we can continue discussing.  It is a fascinating topic, and there are many resources out there.</p> <p>Back already? Ok, so here is pylliterate's take on this matter.</p> <p>Ideally, for literate programming to work, you would code in a meta-language mixing prose, code, and macros. This is great if everyone that will ever write code in your project is willing to indulge in literate programming. Sadly, I have found that more often that not, this is not the case. Hence, even though it is awesome, literate programming has some major practical drawbacks that, at this moment, make it impossible for many people to apply it widely, including:</p> <ul> <li>Poor support from editors and lack of tooling, which is not just a matter of syntax highlighting. The very feature that makes literate programming extra powerful, i.e., macros, makes it almost impossible for any semantic analysis to work, so forget about intellisense, smart completion, or interactive linting.</li> <li>A hard entry curve, since unfortunately people in the 21st century still learns to code the \"old\" way, that is, code-first. Introducing someone into literate programming is hard because it takes some time to grok it and understand the benefits.</li> <li>It's hard to incrementally switch to it. If you already have a somewhat large program written in the \"traditional\" way, it's very hard to port it to the literate programming paradigm incrementally. </li> </ul> <p>All these reasons make it, at least for me, almost impossible to apply pure literate programming in anything more than toy projects. However, I do love the paradigm, and I do think it makes you a better programmer, and makes your code easier to maintain and understand. I wanted a way to introduce as much of literate programming as possible into the traditional programming paradigms, but still being able to use the same tools, introducing literate programming idiosyncrasies incrementally into existing codebases but \"flying under the radar\" as much as possible, so detractors don't complain.</p> <p>Hence, <code>pylliterate</code> was born. It is called that way in part because is kind of a twist on the literate programming paradigm, and also because it is supposed to help us illiterates to write more literate code.</p>"},{"location":"#so-what-does-pylliterate-propose","title":"So what does pylliterate propose?","text":"<p>Glad you asked. The idea is to encourage a more literate codebase while introducing as few changes as possible. Specifically, you should not need to use new tools, editor extensions, or preprocessors. Code written using the  pylliterate style looks exactly like regular code, but hopefully, a bit better.</p> <p>Everything stems from these key principles:</p> <ul> <li>Documentation for a codebase should be written as prose, and it should be enjoyable to read it top to bottom.  It should not be simply a list of modules and methods with few-line descriptions; rather, it should be a cohesive piece of literature that clearly explains the authors' intents for any small details and how everything fits into the bigger picture.</li> <li>Documentation should be as close as possible to real code, ideally right next to it, instead of in external  markdown files that can easily get out of sync. Furthermore, there should be some automated way to ensure that documentation is up to date, ideally with embedded unit tests that fail if documentation is wrong.</li> <li>Documentation should be written both for users of your code and future developers, and it should be easy for anyone to dive as deep as they want. This means that users only interested in calling your high-level API can easily understand how to use it, while collaborators or anyone wanting to understand how everything works should also be able to follow all the details.</li> </ul> <p>To achieve these objectives, pylliterate proposes really only one major paradigm shift:</p> <p>Your code is the documentation.</p> <p>That's it. You will simply write all the documentation for your code right inside your code, as comments and as Python docstrings, according that what is more convenient for each case. But keep this in mind, all your code will be published as-is for documentation purposes.</p> <p>Now you are forced to think about your code in terms of: \"well, this will be read by users at some point, so I better make it as publishable as possible\". This means that you can no longer simply put some throw-away code in some forsaken <code>_tmp.py</code> file. That file will appear in the documentation, so it better be publishable.</p>"},{"location":"#how-this-works","title":"How this works?","text":"<p>The only thing that pylliterate does is taking your Python repository and turn it into Markdown files. It will parse all your code, and output nicely formatted Markdown versions of each <code>.py</code> file. It is up to you that what is writen in those <code>.py</code> files is something worth publishing as documentation.</p> <p>To use it, you simply run:</p> <pre><code>python -m pylliterate build --src input:output --src .....\n</code></pre> <p>Where <code>input</code> is a folder or file holding your project's code (i.e., the top-level folder with an <code>__init__.py</code> inside), and <code>output</code> is where you want the markdown files. You can add  the <code>--src</code> argument as many times as needed even for copy verbatim files.</p> <p>I can do this for copying the <code>Readme.md</code> into an <code>index.md</code> which becomes the homepage.</p> <pre><code>python -m pylliterate build --src Readme.md:docs/index.md\n</code></pre> <p>For example, in this project, standing on the root folder (where this Readme is located), you would run the following (\ud83e\udd13 yeah, it is kind if Inception-ish):</p> <pre><code>python -m pylliterate --src pylliterate:docs --src Readme.md/index.md\n</code></pre> <p>This will take all the code in <code>pylliterate</code>, convert it to Markdown, and drop it inside the <code>docs</code> folder. It will also copy the <code>Readme.md</code> file into <code>docs/index.md</code>.</p>"},{"location":"#a-tweak-using-settings","title":"A tweak using settings.","text":"<p>The same procedure can be obtained using configuration files. The configuration files have the following structure:</p> <pre><code>inline: true # true if we want to process the comments within code blocks\nsources: # List of files to be processed or copied\n  python_package/sample_input.py: sample_docs_folder/sample_input.md  # input:output pair as in command line use case\n</code></pre> <p>The configuration is usually in a file called pylliterate.yml somehow mimicking mkdocs.</p> <p>You can mix pylliterate with regular markdown simply by hand-crafting all the documentation you want in pure Markdown and then conveniently designing your <code>mkdocs.yml</code>. You can also see the <code>mkdocs.yml</code> in this repository to get an idea of how that configuration looks, but beware, I'm using some custom themes and other stuff you might or might not want.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>This project is quite small, but it is a self-fulfilling prophecy. The remaining documentation has been written with <code>pylliterate</code>. Just keep reading, and you'll see for yourself what does this mean.</p>"},{"location":"pylliterate/__init__/","title":"pylliterate","text":"<p>Pylliterate</p> <p>Pylliterate is a Python library for crafting self-documenting code, loosely following the literate programming paradigm. The library itself is coded following pylliterate \"best practices\", so by reading this, either in source code or in the rendered documentation, you should be able to understand what we want to achieve. If you don't, then we have done a pretty bad job.</p> <p>The basic idea is that code should be self-explanatory, but not in the sense that it doesn't require comments. Rather, it should be self-explanatory because comments and code together flow naturally and interweave with each other in a manner that is easy to read by people beyond those who wrote it.</p> <p>This means that comments should be writen in prose, with correct grammar, and not in short phrases next to some instructions without any context. It should be pleasing to read.</p> <p>This also means that you are forced to organize your source code in a way that allows the narrative to flow. For example, it will force you to put the most important definitions (clases and methods) at the top, and leave implementation details for the end.</p> <p>I know some will complain, and say \"but why am I forced to organize my code in a specific way!?\". Well, there is no real restriction to organizing code in Python other than for scoping rules, i.e., that any symbol you use is already defined before. Other than that, you either don't care how the code is organized, in which case it is better to have some guidelines, or you do care how your code is organized. In this second case, if the way your code is organized is not already optimized for readability, then my opinion is that you're organizing it wrong. Plain and simple.</p> <p>With pylliterate, you always organize your code in the way that best fits the explanation. And when you are required to import something or define something at some point, then you better have a good excuse for including it there. If you're doing it right, you should have already explained your why's, and you should be fairly justified at that point.</p> <p>To get in the right mindset for this paradigm shift, think of your source in the following terms. You are a narrator talking to yourself (the future you), trying to explain how this code works. Instead of the code being the important thing, is the narrative what matters. The code just happens to be inserted into some points of the narrative to actually do what the narrative says.</p> <p>There are many ways to explain an idea, but one of the most successful from my point of view is by trying to answer the following questions, in order: why, what, and how. Always start with the motivation, why is code necessary, to solve which problem? Then move to the proposed solution, what are you actually going to do, which are the components of the solution? And then add the implementation details: how is each subtask implemented?</p> <p>There are many advantages to this idea. Two of the most important ones are:</p> <ul> <li> <p>Anyone reading this code in the future should be able to understand it, specially because   now not only the implementation details are there, but also all the motivation behind choosing some   approach rather than another.</p> </li> <li> <p>It will make much easier for yourself to actually develop the project because it will   force you to think about the problem you want to solve before thinking about the solution. And it will   force you to write down explicitly what is that problem, what is the expected solution, which are the main   assumptions.</p> </li> </ul>"},{"location":"pylliterate/__init__/#writing-as-a-pylliterate","title":"Writing as a pylliterate","text":"<p>Now let's talk about using pylliterate. As you have seen so far, these are just regular comments in the code. That's it, nothing has changed. You just need the right mindset.</p> <p>Each comment will be parsed and ultimately rendered as Markdown, so you are free to include any Markdown styling that you want, including lists, bold, <code>code</code>, and even sections (using <code>##</code>). At the beginning of this file you can see the docstrings. They are rendered exactly the same in the final documentation as regular Markdown, but since they also serve as the internal documentation of this module for IntelliSense purposes, you have to decide how much narrative do you want to be part of the \"core\" documentation.</p> <p>And then you just add the code as always. Illiterate Python files are just regular Python files, so everything should work the same as before.</p>"},{"location":"pylliterate/__init__/#high-level-implementation","title":"High-level implementation","text":"<p>Illiterate is a very simple program. All it does is parse Python files, which are converted to some intermediate representation, and then writes them back in Markdown. However, this \"parsing\" is very simple, because we don't really need to understand the Python code. We just need to separate a file into blocks of Markdown and blocks of Python, and then write that back. There is some nuance here, to be fair, because we do want to handle some low-level annotations, like references to existing types and members, but we'll get there pretty soon.</p> <p>To organize this process, we will have classes that represent the different types of content, and then a very simple parser that scans a file top-to-bottom and builds the corresponding block. At this point, however, we only care about the high-level architecture.</p> <p>Starting at root folder, we will process all the <code>.py</code> files in sequence, producing for each one a markdown file that will be saved to the output folder.</p>"},{"location":"pylliterate/__init__/#the-outer-loop","title":"The outer loop","text":"<p>In the output, filenames will match the folder structure that we find, only changing the <code>.py</code> with an <code>.md</code> extension and every \"/\" with a dot. For example <code>src/moduleA/moduleB/file.py</code> will become <code>output/moduleA.moduleB.file.md</code>. We will use <code>pathlib.Path</code> for that purpose.</p> <pre><code>import shutil\nfrom pathlib import Path\nfrom rich.progress import track\nfrom pylliterate.config import PylliterateConfig\nfrom .core import Parser\n</code></pre> <p>Next comes our top level functions that processes each file. Notice how we also have docstrings in each function, as usual. Docstrings are for guiding developers when inspecting our code via IntelliSense and such. Hence, they should be fairly self-contained.</p> <p>You will also notice that methods have comments, as usual. However, inline comments do not lend themselves very well to a coherent and flowing narrative. They are better suited to explain very concise ideas. For this reason, pylliterate won't render those comments as Markdown. They are an integral part of your code, and will be rendered as code. If you want to render them as Markdown, you will have to explicitly pass <code>--inline</code> in the CLI.</p> <p>Hence, you will be forced to refactor your methods so that they are as small as possible. That way, they will have as little comments as possible, ideally none, because the surrounding comments are already enough to make everything as clear as it needs to be. If a method, including comments, is longer than one screen of text, consider refactoring it.</p>"},{"location":"pylliterate/__init__/#processing-each-file","title":"Processing each file","text":"<p>Processing a single file is quite straightforward as well. We will be using a <code>Parser</code> class that does all the heavy-lifting. We feed the parser with the input, and it will return an object (of type <code>Content</code>) that knows how to write itself into a file in Markdown. Note that we just used two internal references in the previous sentences. We'll see how these special constructions are handled when look at the parser implementation but, spoiler alert, it involves some regex. Be aware of the  <code>PylliterateConfig</code> class that hold parameters needed in each processing file</p> <p></p> <pre><code>def process(input_path: Path, output_path: Path, config: PylliterateConfig):\n</code></pre> <p>We need to create this folder hierarchy if it doesn't exist:</p> <pre><code>    output_path.parent.mkdir(exist_ok=True)\n</code></pre> <p>First we check if this is just a regular copy</p> <pre><code>    if input_path.suffix != \".py\":\n        shutil.copy(input_path, output_path)\n        return\n</code></pre> <p>Otherwise, we parse, passing also the file name.</p> <pre><code>    with input_path.open() as fp:\n        content = Parser(\n            fp, config=config, module_name=input_path.name, location=input_path.parent\n        ).parse()\n</code></pre> <p>And then we dump the parsed content.</p> <pre><code>    with output_path.open(\"w\") as fp:\n        content.dump(fp)\n</code></pre> <p>Now is easy process all configured files at once</p> <p></p> <pre><code>def process_all(cfg: PylliterateConfig):\n    files = list(cfg.files)\n</code></pre> <p>This function does all the heavy-lifting...</p> <pre><code>    for input_path, output_path in track(files):\n        process(input_path, output_path, cfg)\n</code></pre> <p>And that's it. As you can see, being forced to describe our process in this way also forces us to write pretty small methods, and to organize our code in the way that is easier to explain. This might seem daunting at first, but believe me (and thousands of computer scientists and software engineers that have been saying this for decades), every effort that you take now to make your code more readable will be paid in the future when you have to come back.</p>"},{"location":"pylliterate/__init__/#where-to-go-from-here","title":"Where to go from here?","text":"<p>As you have seen, pylliterate makes no assumption about the order in which your files will be read. If you want to force a particular order, that goes into your <code>mkdocs.yml</code> (or wherever your documentation engine says). However, since this is Markdown, you can include links anywhere you want, since only you know how your documentation engine generates links.</p> <p>Illiterate automatically generates anchors for top-level definitions of classes and methods, in the form <code>ref:module:ClassName</code> or <code>ref:module:method_name</code>. As an example, you can read more about the <code>Parser</code> (which is an auto-generated link) or you can directly see how the CLI works.</p>"},{"location":"pylliterate/__main__/","title":"pylliterate.main","text":"<p>This module simply allows calling pylliterate as <code>python -m pylliterate</code>. We just import the CLI app and set up the right name so that documentation is correct.</p> <pre><code>from .cli import app\n\nif __name__ == \"__main__\":\n    app(prog_name=\"python -m pylliterate\")\n</code></pre>"},{"location":"pylliterate/cli/","title":"pylliterate.cli","text":"<p>This module contains the pylliterate CLI application.</p> <p>The CLI application is basically a Typer application with three commands, that manage the whole process.</p> <p>The pylliterate CLI app is a very simple Typer application with three commands. Typer is a CLI creation tool where you define commands as methods, and it takes advantage of Python type annotations to provide argument parsing and documentation.</p> <pre><code>import typer\nimport yaml\n</code></pre> <p>These two are for watching file changes.</p> <pre><code>from watchdog.events import FileModifiedEvent, FileSystemEventHandler\nfrom watchdog.observers import Observer\n</code></pre> <p>And these are internal.</p> <pre><code>from pylliterate import process_all, process\nfrom pylliterate.config import PylliterateConfig\n</code></pre> <p>These are the types for our arguments, and <code>shutil</code> for copying files.</p> <pre><code>from pathlib import Path\nfrom typing import List\n</code></pre> <p>We start by creating the main typer application and a set of related commands.</p> <pre><code>app = typer.Typer()\n</code></pre>"},{"location":"pylliterate/cli/#command-helpers","title":"Command helpers","text":"<p>Most of the commands will take either CLI args or a --config file. So we will define a private function to take care of configuration load  either from a specified configuration file or using default values and parameters provided</p> <p></p> <pre><code>def _load_config(src, inline, linenums, highlights, title, config):\n    if config:\n        with config.open() as fp:\n            cfg = PylliterateConfig(**yaml.safe_load(fp))\n    elif not src and Path(\"pylliterate.yml\").exists():\n        with open(\"pylliterate.yml\") as fp:\n            cfg = PylliterateConfig(**yaml.safe_load(fp))\n    else:\n        if not src:\n            typer.echo(\"At least one source or a config file must be provided.\")\n            raise typer.Exit(1)\n        cfg = PylliterateConfig.make(sources=src, inline=inline, linenums=linenums,\n                                     highlights=highlights, title=title)\n    return cfg\n</code></pre> <p>Then we use a decorator to bookkeeping common code between all commands</p> <p></p> <pre><code>def pylliterate_command(fn):\n    def command(\n            src: List[str] = typer.Option([]),\n            inline: bool = False,\n            linenums: bool = False,\n            highlights: bool = False,\n            title: bool = False,\n            config: Path = None,\n    ):\n        cfg = _load_config(src, inline, linenums, highlights, title, config)\n        return fn(cfg)\n\n    return command\n</code></pre>"},{"location":"pylliterate/cli/#the-build-command","title":"The build command","text":"<p>Here is the implementation of the build command is called when <code>python -m pylliterate build</code> is used. This command parse and creates the documentation based on its input parameters.</p> <p></p> <pre><code>@app.command(\"build\")\n@pylliterate_command\ndef build(config: PylliterateConfig):\n    process_all(config)\n</code></pre>"},{"location":"pylliterate/cli/#the-config-command","title":"The config command","text":"<pre><code>@app.command(\"config\")\n@pylliterate_command\ndef config(config: PylliterateConfig):\n    print(yaml.safe_dump(config.dict()))\n\n\nclass IlliterateHandler(FileSystemEventHandler):\n    def __init__(\n            self, input_path: Path, output_path: Path, cfg: PylliterateConfig\n    ) -&gt; None:\n        super().__init__()\n        self.cfg = cfg\n        self.input_path = input_path\n        self.output_path = output_path\n\n    def on_modified(self, event: FileModifiedEvent):\n        typer.echo(f\"Recreating: {self.input_path} -&gt; {self.output_path}\")\n        process(self.input_path, self.output_path, self.cfg)\n\n\n@app.command(\"watch\")\n@pylliterate_command\ndef watch(config: PylliterateConfig):\n    process_all(config)\n    observer = Observer()\n\n    for input_path, output_path in config.files:\n        observer.schedule(\n            IlliterateHandler(input_path, output_path, config), input_path\n        )\n\n    observer.start()\n    observer.join()\n</code></pre>"},{"location":"pylliterate/config/","title":"pylliterate.config","text":"<p>This module contains the pylliterate configuration class</p> <p>The configuration class is a mapper between user define configuration and a python object.</p> <p>We start as usually,  importing necessary modules</p> <pre><code>import logging\nfrom functools import cached_property\nfrom pathlib import Path\nfrom typing import Dict, List\nfrom pydantic import BaseModel\n\nlogger = logging.getLogger(\"pylliterate\")\n</code></pre>"},{"location":"pylliterate/config/#the-configuration-class","title":"The configuration class","text":"<p>We define a configuration class for Pylliterate using Pydantic's BaseModel for proper auto mapping and validation</p> <p></p> <pre><code>class PylliterateConfig(BaseModel):\n</code></pre> <p>'inline' specifies if the documentation is shown inline within the source code</p> <pre><code>    inline: bool = False\n</code></pre> <p>'title' specifies if headings/titles should be created in the documentation</p> <pre><code>    title: bool = False\n</code></pre> <p>'linenums' specifies if line numbers should be included in the documentation</p> <pre><code>    linenums: bool = False\n</code></pre> <p>'highlights' specifies if code snippets should be highlighted</p> <pre><code>    highlights: bool = False\n</code></pre> <p>sources is a dictionary mapping source file paths to their respective documentation file paths</p> <pre><code>    sources: Dict[str, str]\n</code></pre> <p>We need a class method that creates an instance of PylliterateConfig from a list of source files and other options, the make method fulfill goal</p> <pre><code>    @classmethod\n    def make(cls, *, sources: List[str], **kwargs):\n</code></pre> <p>initialize empty dictionary</p> <pre><code>        source_dict = {}\n</code></pre> <p>iterate over every source line</p> <pre><code>        for line in sources:\n</code></pre> <p>split the line into the input file path and output file path</p> <pre><code>            input, output = line.split(\":\")\n</code></pre> <p>add the input and output paths to the dictionary</p> <pre><code>            source_dict[input] = output\n</code></pre> <p>return an instance of PylliterateConfig with the specified sources and options</p> <pre><code>        return cls(sources=source_dict, **kwargs)\n</code></pre> <p>Since the sources attribute is a user-friendly representation of the file system, we need to process it in order to use it correctly. That's what the property files does.</p> <pre><code>    @cached_property\n    def files(self):\n</code></pre> <p>iterate over all items (input and output paths) in the sources dictionary</p> <pre><code>        for input_path, output_path in self.sources.items():\n</code></pre> <p>yield a tuple of Path objects for the input source file and its corresponding documentation file</p> <pre><code>            in_path, out_path = Path(input_path).resolve(), Path(output_path).resolve()\n</code></pre> <p>if the input path if a directory we try to expand it</p> <pre><code>            if in_path.is_dir() and out_path.is_dir():\n                for file in in_path.rglob(\"*.py\"):\n                    yield (in_path / file.relative_to(in_path)), (out_path / in_path.relative_to(Path.cwd()) / str(file.relative_to(in_path))\n                                                                  .replace(\".py\", \".md\"))\n            elif in_path.is_file():\n                print(in_path, out_path)\n                yield in_path, out_path\n            else:\n                logger.warning(f\"Improper input or output path for {in_path} and {out_path}.\")\n</code></pre>"},{"location":"pylliterate/core/","title":"pylliterate.core","text":"<p>Core</p> <p>This module contains the classes that represent the types of content inside a Python file and perform the necessary conversions.</p> <pre><code>from __future__ import annotations\n\nimport logging\nimport collections\nfrom pathlib import Path\n\nfrom pylliterate.config import PylliterateConfig\n\nlogger = logging.getLogger(\"pylliterate\")\n</code></pre> <p>To represent the different types of content in a single Python file, we will use three classes. These classes will represent, respectively, a block of Markdown text, a block of Python code, and a top-level docstring.</p> <p>The only difference between these types of content that we care of is how they are printed as Markdown. Other than that, all types of content are simply a list of text lines.</p> <p>There is however one common functionality for all of them. Depending on how the file is structured, we might end up with spurious empty lines at the beginning or end of any block. This might not be a big issue for Markdown, in some cases, but it is definitely a problem for Python code. Hence, we will remove all the empty lines at the beginning and the end of each block.</p> <p>The common functionality will go into an abstract class.</p> <pre><code>import abc\nimport re\nimport enum\nfrom typing import TextIO, List\n</code></pre>"},{"location":"pylliterate/core/#content-blocks","title":"Content Blocks","text":"<p>The only relevant functionality in this class is cleaning up the list of content. We also define an abstract method <code>print</code> which inheritors will override to determine how different types of content are printed.</p> <p></p> <pre><code>class Block(abc.ABC):\n    def __init__(self, name: str, content: List[str], module_name: str, lineno: int):\n        self.module_name = module_name\n        self.lineno = lineno\n        self.name = name\n\n        while content:\n            if not content[0].strip():  # testing for emptyness\n                content.pop(0)  # from the top down\n            else:\n                break\n\n        while content:\n            if not content[-1].strip():  # testing for emptyness\n                content.pop()  # from the bottom up\n            else:\n                break\n\n        self.content = content\n\n    def __str__(self):\n        return \"\".join(self.content)\n\n    @abc.abstractmethod\n    def print(self, fp: TextIO, content: Content):\n        pass\n\n    def extra(self) -&gt; List[Block]:\n        return []\n</code></pre> <p>Markdown blocks are either formed by lines starting with <code>#</code> (i.e., Python comments) or blank lines. For every line that starts with <code>#_</code>, we simply remove the first two characters, i.e., the sharp symbol and the starting space. For blank lines, we just output them as-is.</p> <p>The only slightly complex functionality in Markdown blocks is formatting references. We want to write something <code>ref:illiterate/core:Markdown</code> in our documentation, and have it translated automatically to <code>../illiterate/core#ref:Markdown</code>.</p> <p></p> <pre><code>class Markdown(Block):\n    hl_re = re.compile(r\":hl:(?P&lt;ref&gt;[a-zA-Z0-9_]+):\")\n    include_re = re.compile(r\":include:((?P&lt;start&gt;-?\\d+):)?((?P&lt;end&gt;-?\\d+):)?(?P&lt;file&gt;.*):\")\n\n    def print(self, fp: TextIO, content: Content):\n        for line in self.content:\n            line = self.fix_links(line.strip())\n\n            if line.startswith(\"# \")\n                if match := self.hl_re.search(line):\n                    ref = match.group(\"ref\")\n                    block = content[ref]\n                    block.print(fp, content)\n                    continue\n\n                if match := self.include_re.search(line):\n                    start = int(match.group('start') or 0) - 1\n                    end = int(match.group('end') or -1)\n                    file = match.group('file')\n\n                    with open(content.location / file) as include:\n                        lines = include.readlines()\n\n                        for line in lines[start:end]:\n                            fp.write(line)\n                    continue\n\n                fp.write(line[2:] + \"\\n\")\n            else:\n                fp.write(\"\\n\")\n\n        fp.write(\"\\n\")\n</code></pre> <p>Fixing the links is very easy if we use a regular expression. Notice that we let the last part (the class or method name) as optional. This means we can link to modules directly with <code>ref:module</code>.</p> <pre><code>    links_re = re.compile(r\"\\(ref:(?P&lt;module&gt;[a-zA-Z_.]+)(:(?P&lt;name&gt;[a-zA-Z_.]+))?\\)\")\n\n    def fix_links(self, line):\n        return self.links_re.sub(r\"(../\\g&lt;module&gt;/#ref\n</code></pre> <p>Python blocks are even easier, since we will print them as-is. There are two points to keep in mind. First is, we need to output a Markdown fenced code block before and after the actual code. Second, we are going to collect all class and method definitions that appear in this block and output some invisible HTML anchors. These anchors won't render in the Markdown or the table of content, but you can use them to link to method. For example, see the <code>Parser</code> class defined below.</p> <p></p> <pre><code>class Python(Block):\n    def __init__(\n            self,\n            name: str,\n            content: List[str],\n            module_name: str,\n            lineno: int,\n            *,\n            highlights=None,\n    ):\n        super().__init__(name, content, module_name, lineno)\n\n        if highlights:\n            self.highlights = \" \".join(str(i + 1) for i in highlights)\n        else:\n            self.highlights = \" \".join(\n                [str(i + 1) for i, l in enumerate(self.content) if \":hl:\" in l]\n            )\n\n    def print(self, fp: TextIO, content: Content):\n        lines = []\n\n        for line in self.content:\n                continue\n</code></pre> <p>To get all valid anchors we'll make use of a simple regular expression.</p> <p>Warning</p> <p>The current implementation only works with top-level definitions of classes and methods. To extend this to second-level definitions and beyond, we're going to have to introduce some sort of stack to keep track of the outer definitions, because a class name can be defined in a different Python block than its inner methods.</p> <pre><code>    anchor_re = re.compile(r\"(?P&lt;type&gt;(class|def))\\s(?P&lt;name&gt;[a-zA-Z0-9_]+)\")\n\n    def get_anchors(self):\n        anchors = []\n\n        for line in self.content:\n            match: re.Match = self.anchor_re.match(line)\n\n            if match:\n                anchors.append(f\"&lt;a name=\\\"ref:{match.group('name')}\\\"&gt;&lt;/a&gt;\")\n                logger.debug(\"Found anchor: %r\" % match)\n\n        return anchors\n\n    def strip(self, line: str):\n        result = []\n        comment = False\n\n        for c in line:\n            if c == \"#\"\n                comment = True\n\n            if c == \":\" and comment:\n                break\n\n            result.append(c)\n\n        return \"\".join(result).rstrip().rstrip(\"#\")\n\n    ref_re = re.compile(r\":ref:(?P&lt;ref&gt;[a-zA-Z0-9_]+):\")\n\n    def extra(self):\n        refs = collections.defaultdict(list)\n\n        for i, line in enumerate(self.content):\n            if match := self.ref_re.search(line):\n                refs[match.group(\"ref\")].append(i)\n\n        return [\n            Python(\n                name=key,\n                content=self.content,\n                module_name=self.module_name,\n                lineno=self.lineno,\n                highlights=value,\n            )\n            for key, value in refs.items()\n        ]\n</code></pre> <p>Another interesting type of content is module-level docstrings. Instead of outputting these as standard Python code, we'll use a block quote.</p> <p></p> <pre><code>class Docstring(Block):\n    def print(self, fp: TextIO, content: Content):\n        fp.write('??? note \"Docstring\"\\n')\n\n        for line in self.content:\n            line = line.strip().replace('\"\"\"', \"\")\n            fp.write(f\"    {line}\\n\")\n</code></pre> <p>Once we have our content types correctly implemented, we will define a container class that stores a sequence of possible <code>Block</code>s. This will make it easier later to dump a bunch of different blocks with a single instruction.</p> <p></p> <pre><code>class Content:\n    def __init__(self, content: List[Block], config: PylliterateConfig, location: Path) -&gt; None:\n        self.content = content\n        self.config = config\n        self.location = location\n        self._by_name = {block.name: block for block in content}\n\n        for block in content:\n            for extra in block.extra():\n                self._by_name[extra.name] = extra\n\n    def __getitem__(self, key) -&gt; Block:\n        return self._by_name[key]\n\n    def dump(self, fp: TextIO):\n        for block in self.content:\n            block.print(fp, self)\n</code></pre>"},{"location":"pylliterate/core/#the-parser","title":"The Parser","text":"<p>Finally, we have come to the core functionality of <code>illiterate</code>, the class that reads Python source code and produces the corresponding blocks. The parser is then a very simple automaton with three states.</p> <p>Since we don't really care about the structure of the code, this parser is very simple. Formally, we are dealing with a regular language, since we can determine what type of content we are dealing with based solely on the first character.</p> <p></p> <pre><code>class Parser:\n    def __init__(\n            self, input_src: TextIO, module_name: str, config: PylliterateConfig, location: Path\n    ) -&gt; None:\n        self.input_src = input_src\n        self.config = config\n        self.module_name = module_name\n        self.content = []\n        self.state = State.Markdown\n        self.lineno = 1\n        self.location = location\n</code></pre> <p>The automaton switches states according to the first character of the current line. Intuitively, as long as we are seeing either a <code>#</code> or blank lines, we are seeing Markdown. Once we see a line that doesn't begin with a <code>#</code>, that must be code or docstring.</p> <p>If <code>inline == True</code>, which is activated with <code>--inline</code> in the CLI, we will parse any comments that appear on a line by itself, such as these, as Markdown. Otherwise, only comments that appear exactly at the beginning of the line will be considered Markdown, and the rest will be parsed as code.</p> <p>Doctrings always start with \"\"\". Once inside a docstring, until a line doesn't end with \"\"\", we assume everything is part of the string.</p> <pre><code>    def parse(self):\n        self.content = []\n        current = []\n\n        for line in self.input_src:\n            if self.state == State.Docstring:\n</code></pre> <p>If we are in the Docstring node and in the line there is the symbols to close it We must parse the current content and to change our state</p> <pre><code>                if '\"\"\"' in line:\n</code></pre> <p>It should matter if the closed symbol is down the text or at the end of the last line</p> <pre><code>                    current = self.store(current)\n                    self.state = State.Markdown\n\n            elif self.state == State.Python:\n\n                if line.startswith(\"#\") or (\n                        self.config.inline and line.strip().startswith(\"#\")\n                ):\n                    current = self.store(current)\n                    self.state = State.Markdown\n\n                elif line.strip().startswith('\"\"\"'):\n                    current = self.store(current)\n                    self.state = State.Docstring\n\n                elif len(re.findall(r'\"\"\"', line)) == 1:\n                    self.state = State.PythonWithDocstring\n\n            elif self.state == State.PythonWithDocstring:\n</code></pre> <p>A docstring is only a string block that they don't matter for the logic of program. But we can also use the syntax \"\"\"....\"\"\" to define some important strings into our program. So, to detect when is a docstring or no we need a new state</p> <pre><code>                if line.startswith(\"#\") or (\n                        self.config.inline and line.strip().startswith(\"#\")\n                ):\n                    self.state = State.Python\n                    current = self.store(current)\n                    self.state = State.Markdown\n\n                elif len(re.findall(r'\"\"\"', line)) == 1:\n                    self.state = State.Python\n\n            elif self.state == State.Markdown:\n                if line.strip().startswith('\"\"\"'):\n                    current = self.store(current)\n                    self.state = State.Docstring\n                elif not (\n                        line.startswith(\"#\")\n                        or (self.config.inline and line.strip().startswith(\"#\"))\n                ):\n                    current = self.store(current)\n                    self.state = State.Python\n\n            current.append(line)\n\n        self.store(current)\n\n        return Content(self.content, self.config, self.location)\n</code></pre> <p>This small utility function creates the actual <code>Block</code> instance. We make return an empty list so that we can use it as shown before, by calling it and restoring <code>current = []</code> in the same line.</p> <pre><code>    def store(self, current):\n        if not current:\n            return []\n\n        name = f\"block-{len(self.content)}\"\n\n        if self.state == State.Markdown:\n            self.content.append(Markdown(name, current, self.module_name, self.lineno))\n        elif self.state == State.Python:\n            self.content.append(Python(name, current, self.module_name, self.lineno))\n        elif self.state == State.Docstring:\n            self.content.append(Docstring(name, current, self.module_name, self.lineno))\n\n        self.lineno += len(current)\n\n        return []\n</code></pre> <p>Finally, here are the states.</p> <p></p> <pre><code>class State(enum.Enum):\n    Markdown = 1\n    Docstring = 2\n    Python = 3\n    PythonWithDocstring = 4\n</code></pre> <p>And this is it \ud83d\udd96.</p>"}]}